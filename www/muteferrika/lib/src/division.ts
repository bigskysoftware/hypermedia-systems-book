// Generated by CoffeeScript 2.7.0

import { makeSlug } from "./slug.ts";
import * as find from "./find.ts";
import * as template from "./template.ts";
import * as markdown from "./markdown.ts";
import { intl, Language } from "./intl.ts";
import { serializeDocument, serializeFragment } from "./html.ts";
import type { Book } from "./content-types.ts";

import {
  Document,
  DocumentFragment,
  DOMParser,
  HTMLTemplateElement,
} from "../deps/deno-dom.ts";

export type TableOfContentsOptions = {
  includeChildren: boolean;
  includeContent: boolean;
  include: boolean;
  // Does numbering need to be here or can it all be done in CSS?
  numbering: unknown;
};

export default class Division {
  // #region content type attributes

  static tableOfContents: Partial<TableOfContentsOptions> = {};

  static template = "division.html";

  static htmlClass?: string;

  // #endregion

  // #region build

  dependencies: Record<string, find.Query> = {};

  async buildPhase1(
    deps: Record<string, Division[]>,
    book: Division,
  ) {
    this.compiledContent ??= await this.compile(
      await this.preprocess(
        await this.load(),
        deps,
        book,
      ),
      deps,
      book,
    );
  }

  async buildPhase2(
    deps: Record<string, Division[]>,
    book: Division,
  ): Promise<string> {
    if (typeof this.compiledContent !== "string") {
      throw new Error("Build phase 2 called before phase 1 complete");
    }

    const processed = await this.process(this.compiledContent, deps, book);

    // TODO: completely revamp how DOM manipulation works
    if (this.#didAccessDom) {
      this.compiledContent = serializeFragment(this.#dom!);
    } else if (typeof processed === "string") {
      this.compiledContent = processed;
    }

    const laidOut = await this.layout(this.compiledContent!, deps, book);
    this.builtContent = laidOut;
    const postprocessed = await this.postprocess(laidOut, deps, book);

    if (this.#didAccessDocument) {
      this.builtContent = serializeDocument(this.document!);
    } else {
      this.builtContent = postprocessed;
    }
    return this.builtContent;
  }

  async preprocess(
    content: string,
    deps: Record<string, Division[]>,
    book: Division,
  ) {
    return content;
  }

  async compile(
    content: string,
    deps: Record<string, Division[]>,
    book: Division,
  ) {
    return markdown.render(content);
  }

  async process(
    content: string,
    deps: Record<string, Division[]>,
    book: Division,
  ): Promise<string | void> {
    return content;
  }

  async layout(
    content: string,
    deps: Record<string, Division[]>,
    book: Division,
  ): Promise<string> {
    const res = await template.render(
      this.contentType.template,
      this,
      serializeFragment(this.dom),
    );
    return res.content;
  }

  async postprocess(
    content: string,
    deps: Record<string, Division[]>,
    book: Division,
  ) {
    return content;
  }

  async load(): Promise<string> {
    if (this.content) {
      return this.content;
    } else if (this.file) {
      return Deno.readTextFileSync(this.file);
    } else if (this.title) {
      // refactor
      return Deno.readTextFile(`${makeSlug(this.title)}.md`).catch(() => "");
    }
    return "";
  }

  #source: string | null = null;

  get document() {
    this.#didAccessDocument = true;
    if (this.#document !== null) return this.#document;
    return this.#document = this.#getDocument();
  }

  #getDocument() {
    return new DOMParser().parseFromString(this.builtContent!, "text/html");
  }

  #document: Document | null = null;
  #didAccessDocument = false;

  get dom(): DocumentFragment {
    this.#didAccessDom = true;
    if (this.#dom !== null) return this.#dom;
    return this.#dom = this.#getDom();
  }

  #getDom() {
    if (this.compiledContent === undefined) {
      console.warn(
        `Attempted to access DOM of ${this} before compiling content`,
      );
      return new Document().createDocumentFragment();
    }
    const tmpl = new Document()
      .createElement("template") as HTMLTemplateElement;
    tmpl.innerHTML = this.compiledContent;
    return tmpl.content;
  }

  #dom: DocumentFragment | null = null;
  #didAccessDom = false;

  get language(): Language {
    if (this.lang) return this.lang;
    if (this.parent) return this.parent.language;
    return "en";
  }

  // #endregion

  // #region Instance properties

  self = this;

  children: Division[] = [];

  previous?: Division;

  next?: Division;

  parent?: Division;

  url?: string;

  content?: string;

  compiledContent?: string;

  builtContent?: string;

  title?: string;

  lang?: Language;

  date?: string;

  file?: string;

  author?: string;

  // #endregion

  // #region content type wrappers

  get contentType(): ContentType {
    return this.constructor as ContentType;
  }

  get template() {
    return this.contentType.template;
  }

  get htmlClass() {
    return this.contentType.htmlClass;
  }

  get tocInclude() {
    return this.contentType.tableOfContents.include ?? true;
  }

  get tocIncludeChildren() {
    return this.contentType.tableOfContents.includeChildren ?? true;
  }

  get tocIncludeContent() {
    return this.contentType.tableOfContents.includeContent ?? true;
  }

  getUrl() {
    return (this.url ?? (this.title && "/" + makeSlug(this.title))) || null;
  }

  toString() {
    return "ยง(" + JSON.stringify(
      this.title ?? this.file ?? this.contentType.name,
    ) + ")";
  }

  *allSubdivisions(): Iterable<Division> {
    for (const child of this.children) {
      yield child;
      yield* child.allSubdivisions();
    }
  }

  // #endregion

  // #region TOC hierarchy

  /**
   * Navigate upward in the hierarchy,
   * ignoring divisions not included in the TOC.
   */
  upward(): Division | null {
    const parent = this.parent;
    if (!parent) return null;
    if (parent.tocInclude) return parent;
    else return parent.upward();
  }

  /**
   * Get the next division in the hierarchy,
   * ignoring divisions not included in the TOC.
   */
  forward(): Division | null {
    const first = this.downward()[Symbol.iterator]().next().value;
    if (first) return first;
    const next = this.next;
    if (!next) {
      return this.parent?.forwardAfterEnd() ?? null;
    }
    if (next.tocInclude) return next;
    else return next.forward();
  }

  forwardAfterEnd(): Division | null {
    const next = this.next;
    if (!next) {
      return this.parent?.forwardAfterEnd() ?? null;
    }
    if (next.tocInclude) return next;
    else return next.forward();
  }

  /**
   * Get the previous division in the hierarchy,
   * ignoring divisions not included in the TOC.
   */
  backward(): Division | null {
    const prev = this.previous;
    if (!prev) return this.upward();
    if (prev.tocInclude) return prev;
    else return prev.backward();
  }

  /**
   * Get subdivisions that are to be included
   */
  *downward(): Iterable<Division> {
    if (!this.tocIncludeChildren) return;
    for (const child of this.children) {
      if (child.tocInclude) yield child;
      else yield* child.downward();
    }
  }

  get book(): Book | null {
    let rv: Division = this;
    while (rv.parent) rv = rv.parent;
    return rv;
  }

  // #endregion

  constructor(title?: string) {
    if (typeof title === "string") this.title = title;
  }

  with(...args: (Partial<this> | Division | Division[])[]): this {
    for (const arg of args) {
      if (Array.isArray(arg)) {
        this.children.push(...arg.flat());
      } else if (arg instanceof Division) {
        this.children.push(arg);
      } else {
        Object.assign(this, arg);
      }
    }
    for (const [i, child] of this.children.entries()) {
      child.parent = this;
      child.previous = this.children[i - 1];
      child.next = this.children[i + 1];
    }
    return this;
  }
}

export type ContentType = typeof Division;
