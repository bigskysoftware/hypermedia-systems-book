#import "lib/definitions.typ": *

== 하이퍼미디어: 재소개

하이퍼미디어는 오늘날 보편적인 기술로, 거의 전기만큼이나 흔히 사용됩니다.

수십억의 사람들이 매일 하이퍼미디어 기반 시스템을 사용하며, 주로 웹 브라우저를 통해 월드 와이드 웹에서 _하이퍼텍스트 마크업 언어(HTML)_과 _하이퍼텍스트 전송 프로토콜(HTTP)_을 교환하는 방식으로 상호작용합니다.

사람들은 이 시스템을 이용해 뉴스도 보고, 친구와 소통하며, 온라인 쇼핑, 게임, 이메일 전송 등의 다양한 서비스를 이용합니다. 하이퍼미디어를 통해 제공되는 온라인 서비스의 다양성과 그 수는 정말 놀라운 수준입니다.

그럼에도 불구하고, 이러한 보편성에도 불구하고 하이퍼미디어 자체에 대한 논의는 오늘날 이상할 정도로 탐구가 부족한 개념으로 남아 있으며, 주로 전문가에게 남겨져 있습니다. 네, HTML을 작성하고 링크와 양식 등을 만드는 방법에 대한 많은 튜토리얼을 찾을 수 있습니다. 그러나 HTML을 _하이퍼미디어_로 논의하거나, 전체 하이퍼미디어 _시스템_이 어떻게 맞물리는지에 대해서는 논의되지 않는 경우가 많습니다.

이는 초기 웹 개발 시대와 대조적입니다. 그때는 _표현 상태 전송(REST)_과 _하이퍼미디어를 애플리케이션 상태의 엔진으로(HAEOTAS)_와 같은 개념이 자주 논의되고 정제되었으며, 웹 개발자들 사이에서 활발히 토론되었습니다.

슬프게도, 오늘날 세계에서 가장 인기 있는 하이퍼미디어인 HTML은 종종 불만스러운 시선으로 바라보입니다. 이는 점점 더 JavaScript 기반 웹 애플리케이션을 구축하기 위해 불가피하게 사용해야 하는 불편한 레거시 마크업 언어로 간주됩니다.

HTML은 브라우저에 존재할 뿐이고, 그래서 우리는 그것을 사용해야만 합니다.

이는 안타까운 일이며, 하이퍼미디어가 단순히 우리가 수용해야 하고 다뤄야 하는 레거시 기술의 일부가 아니라는 것을 여러분에게 설득하고자 합니다. 대신, 하이퍼미디어는 견고한 애플리케이션을 구축할 수 있는 매우 혁신적이고 간단하며 _유연한_ 방법임을 보여주고자 합니다: _하이퍼미디어 기반 애플리케이션_.

우리는 이 책의 끝까지 여러분이 웹 개발자로서 다음 애플리케이션의 아키텍처를 고려할 때 하이퍼미디어 접근 방식이 자리를 차지해야 마땅하다고 느끼길 바라며, 하이퍼미디어 시스템 위에 _하이퍼미디어 기반 애플리케이션_을 만드는 것이 현대 웹 애플리케이션에 대한 실행 가능하고 사실상 우수한 선택이 될 수 있다는 점을 보여줍니다.

(그리고 Hyperview에 대한 섹션이 보여줄 것이듯이, 단지 웹 애플리케이션만이 아닙니다.)

=== 하이퍼미디어란 무엇인가? <_what_is_hypermedia>

#blockquote(
  attribution: [Ted Nelson, https:\/\/archive.org/details/SelectedPapers1977/page/n7/mode/2up],
)[
  하이퍼텍스트: 컴퓨터 화면에 나타나 독자의 명령에 따라 가지치기하거나 수행되는 새로운 형태의 글쓰기입니다. 하이퍼텍스트는 비선형적인 글쓰기의 한 형태이며; 오직 컴퓨터 디스플레이가 그것을 실용적으로 만듭니다.
]

처음부터 시작해 보겠습니다: 하이퍼미디어란 무엇인가요?

#index[hypermedia]
하이퍼미디어는 예를 들어 텍스트와 같이 _비선형 분기_를 포함하는 미디어로, 예를 들어 미디어에 내장된 하이퍼링크를 통해 한 위치에서 다른 위치로 전환할 수 있습니다. 접두사 "hyper-"는 "초월" 또는 "위"를 의미하는 그리스어 접두사 "ὑπερ-"에서 유래하여, 하이퍼미디어가 일반적인 수동적으로 소비되는 미디어(예: 잡지와 신문)를 _초월한다_는 것을 나타냅니다.

하이퍼링크는 _#indexed[하이퍼미디어 제어]_의 전형적인 예입니다:

/ 하이퍼미디어 제어: #[
    하이퍼미디어 제어는 원격 서버와의 상호작용을 설명(또는 제어)하는 요소로, 해당 상호작용에 대한 정보를 직접적으로 그리고 완전히 내포하고 있습니다.
  ]

하이퍼미디어 제어는 하이퍼미디어와 다른 유형의 미디어를 구분짓는 요소입니다.

여러분은 _#indexed[하이퍼텍스트]_라는 용어에 더 익숙할 수 있습니다. 위 인용문은 그 위키피디아 페이지에서 가져온 것입니다. 하이퍼텍스트는 하이퍼미디어의 하위 카테고리이며, 이 책의 대부분은 HTML과 같은 하이퍼텍스트를 사용하여 현대 애플리케이션을 구축하는 방법을 논의할 것입니다. HTML은 하이퍼텍스트 마크업 언어이며, HXML은 하이퍼뷰 모바일 하이퍼미디어 시스템에 사용되는 하이퍼텍스트입니다.

HTML과 같은 하이퍼텍스트는 전체 하이퍼미디어 시스템을 작동시키기 위해 필수적인 다른 기술들과 함께 작동합니다: HTTP와 같은 네트워크 프로토콜, 이미지와 비디오와 같은 다른 미디어 유형, 하이퍼미디어 서버(즉, 하이퍼미디어 API를 제공하는 서버), 정교한 하이퍼미디어 클라이언트(예: 웹 브라우저) 등입니다.

이 때문에 우리는 하이퍼텍스트를 기반으로 구축된 애플리케이션의 기본 아키텍처를 설명할 때, 보다 넓은 용어인 _#indexed[하이퍼미디어 시스템]_을 선호합니다. 이는 특정 하이퍼미디어보다 시스템 아키텍처를 강조합니다.

대부분의 현대 웹 개발자들이 간과하고 무시하는 것은 하이퍼미디어 _시스템 아키텍처_입니다.

=== 하이퍼미디어의 간략한 역사 <_a_brief_history_of_hypermedia>
하이퍼미디어라는 아이디어는 어디에서 왔을까요?

#index[Bush, Vannevar]
#index[Memex]
현대 하이퍼텍스트 및 더 일반적인 하이퍼미디어 개념의 많은 전구체들이 있었지만, 많은 사람들은 반네바르 부시(Vannevar Bush)가 _The Atlantic_에 쓴 1945년 기사 _As We May Think_를 현대 하이퍼미디어가 된 개념을 보는 출발점으로 지목합니다.

이 기사에서 부시는 사용자가 관련 콘텐츠 영역 간에 점프할 수 있도록 하는 복잡한 기계 시스템과 엔코딩 시스템을 활용한 장치인 #indexed[Memex]를 설명했습니다. Memex는 실제로 구현된 적이 없지만, 하이퍼미디어 개념에 대한 후속 연구에 영감을 주었습니다.

#index[Nelson, Ted]
"하이퍼텍스트"와 "하이퍼미디어"라는 용어는 1963년에 테드 넬슨에 의해 만들어졌습니다. 그는 브라운 대학교에서 _하이퍼텍스트 편집 시스템_에 대한 작업을 하였고, 나중에 그의 시대에 충격적으로 진보된 하이퍼미디어 시스템인 _파일 검색 및 편집 시스템(#indexed[FRESS])_을 개발했습니다. (이것은 아마도 "실행 취소"라는 개념을 가진 최초의 디지털 시스템이었습니다.)

#index[Engelbart, Douglas]
넬슨이 자신의 아이디어를 발전시키고 있을 무렵, 더글라스 앵글바트는 스탠포드 연구소에서 그 당시 부시의 Memex를 실제화하기 위해 노력하고 있었습니다. 1968년 앵글바트는 샌프란시스코에서 "모든 데모의 어머니"라는 발표를 하였습니다.

앵글바트는 믿을 수 없을 만큼 많은 기술을 시연했습니다:

- 메날로 파크의 동료들과 원격 협업 텍스트 편집
- 비디오 및 오디오 채팅
- 통합된 창 관리 시스템
- 하이퍼텍스트의 인식 가능성으로, 밑줄 친 텍스트를 클릭하면 새로운 콘텐츠로 이동하게 됩니다.

스탠딩 오베이션을 받은 그의 발표 이후, 앵글바트의 기술이 주류가 되기까지는 수십 년이 걸렸습니다.

==== 현대적 구현 <_modern_implementation>

#index[Berners-Lee, Tim]
#index[World Wide Web][creation]
1990년, 팀 버너스리(Tim Berners-Lee)는 CERN에서 첫 번째 웹사이트를 발표했습니다. 그는 10년 동안 하이퍼텍스트 아이디어에 대해 일해 왔으며, 연구자들이 연구 결과를 공유하는 것이 매우 어려웠던 점에서 결단을 내리고 월드 와이드 웹을 만들기 위한 적절한 순간과 제도적 지원을 찾은 것입니다:

#blockquote(
  attribution: [Tim Berners-Lee,
    https:\/\/britishheritage.org/tim-berners-lee-the-world-wide-web],
)[
  웹을 만드는 것은 정말 절망적인 행동이었습니다. 그 상황 없이는 매우 어려웠습니다. 웹과 관련된 대부분의 기술, 하이퍼텍스트와 인터넷, 다중 글꼴 텍스트 객체는 이미 설계되어 있었습니다. 나는 그것들을 결합하면 되는 것이었습니다. 모든 문서 시스템을 더 큰 상상 속의 문서 시스템의 일부로 생각하면서 더 높은 추상화 수준으로 일반화하는 단계였습니다.
]

1994년까지 그의 창조물은 너무 빨리 성장하여 버너스리는 W3C를 설립했습니다. W3C는 웹 개선을 위한 기업과 연구자들로 구성된 작업 그룹이었습니다. W3C에서 만들어진 모든 표준은 로열티가 없으며 누구나 채택하고 구현할 수 있어 웹의 열린 협력적 특성을 확고히 했습니다.

#index[Fielding, Roy]
2000년, 로이 필딩은 U.C. 어바인의 웹에 관한 중요한 박사 논문 "네트워크 기반 소프트웨어 아키텍처의 아키텍처 스타일 및 설계"를 발표했습니다. 필딩은 오픈 소스 아파치 HTTP 서버에서 작업해 왔으며, 그의 논문은 초기 웹에 나타났던 _새롭고 뚜렷한 네트워킹 아키텍처_를 설명한 것입니다. 필딩은 초기 HTTP 사양 작업에 참여하였으며, 논문에서 웹의 하이퍼미디어 네트워크 모델을 _표현 상태 전송(#indexed[REST])_이라는 용어로 정의했습니다.

필딩의 작업은 초기 웹 개발자를 위한 주요 이정표가 되었으며, 그들에게 그들이 애플리케이션을 구축하기 위해 사용하고 있는 새로운 기술 매체에 대해 토론할 수 있는 언어를 제공했습니다.

우리는 2장에서는 필딩의 핵심 아이디어를 깊이 있게 논의하고, REST, HATEOAS 및 하이퍼미디어에 대한 잘못된 기록을 바로잡을 것입니다.

=== 세계에서 가장 성공적인 하이퍼텍스트: HTML <_the_worlds_most_successful_hypertext_html>
#blockquote(
  attribution: [Rescuing REST From the API Winter,
    https:\/\/intercoolerjs.org/2016/01/18/rescuing-rest.html],
)[
  처음에 하이퍼링크가 있었고, 하이퍼링크는 웹과 함께 있었으며, 하이퍼링크가 바로 웹이었다. 그리고 그것은 좋았다.
]

#index[HTML][history]
버너스리, 필딩 및 많은 다른 사람들이 만든 시스템은 하이퍼미디어인 HTML을 중심으로 구성되어 있었습니다. HTML은 처음에는 학술 문서를 발표하기 위해 사용되는 읽기 전용 하이퍼미디어로 시작되었습니다. 이 문서는 앵커 태그를 통해 서로 연결되어 하이퍼링크를 생성하고, 사용자가 문서 간 빠르게 탐색할 수 있게 하였습니다.

#index[HTML][2.0] HTML 2.0이 출시될 때, `form` 태그의 개념을 도입하여 앵커 태그(즉 하이퍼링크)와 함께 두 번째 하이퍼미디어 제어로 자리 잡았습니다. 양식 태그의 도입은 단순히 자원을 읽는 것이 아니라 _업데이트_하기 위한 메커니즘을 제공함으로써 웹에서 _애플리케이션_을 구축하는 것을 가능하게 하였습니다.

이 시점에서 웹은 흥미로운 문서 중심 시스템에서 매력적인 _애플리케이션 아키텍처_로 전환하게 되었습니다.

오늘날 HTML은 존재하는 가장 널리 사용되는 하이퍼미디어이며 이 책은 독자가 이를 어느 정도 익숙하게 다룰 것이라 가정합니다. 이 책의 코드를 이해하는 데 HTML(또는 CSS) 전문가일 필요는 없지만, HTML의 핵심 태그와 개념을 잘 이해할수록 더 많은 것을 얻을 수 있습니다.

==== HTML의 본질로서 하이퍼미디어 <_the_essence_of_html_as_a_hypermedia>
HTML의 두 가지 정의적인 하이퍼미디어 요소(즉, 두 가지 정의적 _하이퍼미디어 제어_인 앵커 태그와 양식 태그)를 좀 더 자세히 살펴보겠습니다.

===== 앵커 태그 <_anchor_tags>

#index[hyperlink]
#index[anchor tag]
앵커 태그는 너무 익숙하여 지루할 지경이지만, 원래의 하이퍼미디어 제어로서 하이퍼링크의 메커니즘을 검토하는 것은 하이퍼미디어에 대한 깊은 이해를 발전시키는 데 도움이 됩니다.

간단한 앵커 태그를 생각해보겠습니다. 이 태그는 보다 큰 HTML 문서 안에 내장되어 있습니다:

#figure(caption: [간단한 하이퍼링크],
```html
<a href="https://hypermedia.systems/">
  하이퍼미디어 시스템
</a>
```)

앵커 태그는 `<a></a>` 태그 자체, 태그 내의 속성 및 내용으로 구성됩니다. 특히 주목할 점은 _하이퍼텍스트 참조_를 다른 문서나 문서 조각으로 지정하는 `href` 속성입니다. 바로 이 속성이 앵커 태그를 하이퍼미디어 제어로 만들어줍니다.

일반적인 웹 브라우저에서 이 앵커 태그는 다음과 같이 해석됩니다:

- "하이퍼미디어 시스템"이라는 텍스트를 클릭할 수 있음을 나타내는 방식으로 표시합니다.
- 사용자가 해당 텍스트를 클릭하면 `https://hypermedia.systems/` URL에 HTTP `GET` 요청을 발행합니다.
- 이 요청에 대한 HTTP 응답 본문에서 HTML 콘텐츠를 가져와서 브라우저의 전체 화면을 새로운 문서로 대체하며, 탐색 바를 새 URL로 업데이트합니다.

앵커는 오늘날 우리가 웹을 탐색하는 주요 메커니즘을 제공합니다. 문서에서 문서로, 또는 자원에서 자원으로 탐색하기 위해 링크를 선택합니다. @fig-get-in-action은 앵커 태그/하이퍼링크와의 사용자 상호작용이 어떤 모습인지 시각적으로 보여줍니다.

#asciiart(
  read("images/diagram/http-get-in-action.txt"), caption: [HTTP GET의 작동],
)<fig-get-in-action>

#index[GET request]
링크를 클릭하면 브라우저(또는 때때로 _하이퍼미디어 클라이언트_라고 부르는)가 링크의 `href` 속성에 인코딩된 URL로 HTTP `GET` 요청을 발행합니다.

이 HTTP 요청은 브라우저가 서버에서 실제로 무엇을 원하는지를 나타내는 추가 데이터(즉, _메타데이터_)를 헤더의 형태로 포함합니다. 이러한 헤더는 2장에서 더 깊이 논의할 것입니다.

_하이퍼미디어 서버_는 이 요청에 대한 응답으로 하이퍼미디어 응답인 HTML을 제공합니다. 이는 사소하고 자명하게 보일 수 있지만, 진정으로 RESTful 하이퍼미디어 시스템에서 절대적으로 중요한 측면입니다: 클라이언트와 서버는 하이퍼미디어를 통해 통신해야만 합니다!

===== 양식 태그 <_form_tags>

앵커 태그는 문서나 자원 간의 _탐색_을 제공합니다. 하지만 자원을 업데이트할 수는 없습니다. 그 기능은 #indexed[양식 태그]에게 맡겨집니다.

HTML의 간단한 양식을 살펴보겠습니다:

#figure(caption: [간단한 양식],
```html
<form action="/signup" method="post">
  <input type="text" name="email" placeholder="가입 이메일 입력하기">
  <button>가입하기</button>
</form>
```)

앵커 태그와 마찬가지로, 양식 태그는 `<form></form>` 태그 자체로 구성되며, 태그 내의 속성과 내용이 결합됩니다. 주목할 점은 양식 태그가 `href` 속성을 가지고 있지 않지만, 오히려 HTTP 요청을 발행할 곳을 지정하는 `action` 속성이 있다는 점입니다.

#index[POST request]
더욱이, 양식 태그는 어떤 HTTP "메서드"를 사용할 것인지 지정하는 `method` 속성도 가지고 있습니다. 이 예제에서 양식은 브라우저에게 `POST` 요청을 발행할 것을 요청하고 있습니다.

앵커 태그와는 달리, 양식 내의 내용과 태그는 양식이 서버와 상호작용할 때 하이퍼미디어 상호작용에 영향을 줄 수 있습니다. `input` 태그와 `select` 태그와 같은 다른 태그의 _값_은 양식이 제출될 때 HTTP 요청과 함께 포함되며, `GET`의 경우 URL 매개변수로, `POST`의 경우 요청 본문으로 포함됩니다. 이로 인해 양식은 사용자가 제공한 임의의 양의 정보를 요청에 포함할 수 있습니다. 이는 앵커 태그와는 다릅니다.

일반적인 브라우저에서 이 양식 태그와 그 내용은 다음과 같이 해석됩니다:

- 사용자에게 텍스트 입력 및 "가입하기" 버튼을 제시합니다.
- 사용자가 "가입하기" 버튼을 클릭하거나 입력 요소에 포커스가 있을 때 Enter 키를 눌러 양식을 제출하면 `/signup` 경로의 "현재" 서버에 HTTP `POST` 요청을 발행합니다.
- HTTP 응답 본문에서 받은 HTML 콘텐츠를 가져와서 브라우저의 전체 화면을 새로운 문서로 대체하며, 탐색 바를 새 URL로 업데이트합니다.

이 메커니즘을 사용하면 사용자가 서버의 자원상태를 _업데이트_하기 위한 요청을 발행할 수 있습니다. 이러한 새로운 유형의 요청이 있음에도 불구하고 클라이언트와 서버 간의 통신은 여전히 완전히 _하이퍼미디어_로 이루어집니다.

양식 태그가 하이퍼미디어 기반 애플리케이션을 가능하게 합니다.

경험이 풍부한 웹 개발자라면, 여기서 몇 가지 세부사항과 복잡한 요소를 생략했음을 인식할 것입니다. 예를 들어, 양식 제출에 대한 응답은 종종 클라이언트를 다른 URL로 _리디렉션_합니다.

이는 사실이며, 우리는 이후 장에서 양식에 대한 구체적으로 깊이 들어가겠지만, 지금은 이 간단한 예가 하이퍼미디어 내에서 시스템 상태를 업데이트하는 핵심 메커니즘을 보여주기에 충분합니다. @fig-post-in-action은 그 상호작용의 다이어그램입니다.

#asciiart(
  read("images/diagram/http-post-in-action.txt"), caption: [HTTP POST의 작동],
)<fig-post-in-action>

===== 웹 1.0 애플리케이션 <_web_1_0_applications>
웹 개발에 관심 있는 사람이라면 위의 다이어그램과 논의가 매우 친숙할 것입니다. 아마도 이 내용을 지루하게 느낄 수도 있습니다. 하지만 잠시 뒤로 물러서서 이 두 하이퍼미디어 제어, 즉 앵커와 양식이 사용자가 HTML에서 서버와 상호작용하는 _유일한_ 기본적인 방법이라는 점을 고려해보십시오.

오직 두 개의 태그뿐입니다!

그럼에도 불구하고, 이 두 태그만으로 초기 웹은 기하급수적으로 성장할 수 있었고, 수십억 사람들에게 놀라울 정도로 많은 온라인 동적 기능을 제공했습니다.

이는 하이퍼미디어의 힘을 보여주는 강력한 증거입니다. 오늘날 점점 더 많은 JavaScript 중심의 프론트엔드 프레임워크가 지배적인 웹 개발 세계에서도, 많은 사람들은 단순한 일반 HTML을 사용하여 애플리케이션 목표를 달성하길 원하며, 결과에 만족합니다.

이 두 태그는 HTML에 엄청난 표현력을 부여합니다.

==== 그렇다면 하이퍼미디어가 아닌 것은? <_so_what_isnt_hypermedia>
링크와 양식은 HTML에서 서버와 상호작용하는 두 가지 주요 하이퍼미디어 기반 메커니즘입니다.

#index[Fetch API]
이제 다른 접근 방식을 고려해 보겠습니다: 자바스크립트를 통해 HTTP 요청을 발행하는 것입니다. 이를 위해 우리는 모든 현대 웹 브라우저에서 사용할 수 있는 인기 API인 #link(
  "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",
)[`fetch()`] API를 사용할 것입니다. 이 API는 "비동기 자바스크립트 및 XML", 또는 AJAX #index[AJAX] 요청을 발행하는 데 사용됩니다:

#figure(caption: [JavaScript],
```html
<button onclick="fetch('/api/v1/contacts/1') <1>
                .then(response => response.json()) <2>
                .then(data => updateUI(data)) "> <3>
    연락처 가져오기
</button>
```)
1. 요청을 발행합니다.
2. 응답을 JavaScript 객체로 변환합니다.
3. 객체로 `updateUI()` 함수를 호출합니다.

이 버튼은 클릭할 때 실행할 JavaScript를 지정하는 `onclick` 속성을 가지고 있습니다.

JavaScript는 `fetch()`를 사용하여 `/api/v1/contacts/1`에 AJAX HTTP `GET` 요청을 발행합니다. AJAX 요청은 "정상적인" HTTP 요청과 비슷하지만, 브라우저가 "백그라운드"에서 발행하는 것입니다. 사용자는 일반 링크나 양식을 사용할 때처럼 브라우저에서 요청 표시기를 볼 수 없습니다. 또한, 이러한 하이퍼미디어 제어로 발행된 요청과 달리, 서버로부터의 응답을 처리하는 것은 JavaScript 코드에 달려 있습니다.

AJAX가 XML을 포함하고 있는 약어이긴 하지만, 오늘날 이 요청에 대한 HTTP 응답은 거의 확실히 JavaScript 객체 표기법(JSON) #index[JSON] 형식으로 되어 있습니다.

이 요청에 대한 HTTP 응답은 다음과 같은 모습일 수 있습니다:

#figure(caption: [JSON],
```json
{ <1>
  "id": 42, <2>
  "email" : "json-example@example.org" <3>
}
```)

1. JSON 객체의 시작.
2. `id`라는 이름과 값 `42`를 가진 속성.
3. 이 ID를 가진 연락처의 이메일.

위의 JavaScript 코드는 `json()` 메서드를 호출하여 서버로부터 받은 JSON 텍스트를 JavaScript 객체로 변환합니다. 이 새로운 JavaScript 객체는 #index[updateUI method] `updateUI()` 메서드로 전달됩니다.

`updateUI()` 메서드는 JavaScript 객체에서 인코딩된 데이터에 따라 UI를 업데이트할 책임이 있으며, 아마도 JavaScript 애플리케이션의 클라이언트 측 템플릿을 통해 생성된 HTML을 표시할 것입니다.

`updateUI()` 함수가 정확히 무엇을 하는지는 우리 논의에서 중요하지 않습니다.

중요한 것은, 이 JSON 기반 서버 상호작용의 _핵심_ 측면이 하이퍼미디어를 사용하지 않는다는 것입니다. 여기에서 사용되는 #indexed[JSON API]는 하이퍼미디어 응답을 반환하지 않습니다. 하이퍼링크나 다른 하이퍼미디어 스타일의 제어는 없습니다.

이 JSON API는 오히려 _#indexed[데이터 API]_입니다.

응답이 JSON이며 _하이퍼미디어_가 아니기 때문에, JavaScript의 `updateUI()` 메서드는 이 연락처 데이터를 HTML로 변환하는 방법을 이해해야 합니다.

특히, `updateUI()`의 코드는 데이터의 _내부 구조_와 의미에 대해 알아야 합니다.

이렇게 알아야 합니다:

- JSON 데이터 객체의 필드가 어떻게 구조화되고 명명되어 있는지.
- 그것들이 어떻게 서로 관련되는지.
- 이 새로운 데이터에 해당하는 로컬 데이터를 어떻게 업데이트할 수 있는지.
- 이 데이터를 브라우저에 어떻게 렌더링할 수 있는지.
- 이 데이터와 함께 호출할 수 있는 추가 작업/API 엔드포인트는 무엇인지.

간단히 말해, `updateUI()`의 논리는 `/api/v1/contact/1`의 API 엔드포인트에 대한 밀접한 지식을 필요로 합니다. 이 지식은 응답 자체 외에 다른 방법으로 제공됩니다. 결과적으로 `updateUI()` 코드와 API는 _#indexed[긴밀한 결합]_이라는 강한 관계를 가지고 있습니다. JSON 응답의 형식이 변경되면, `updateUI()`도 거의 확실히 변경해야 할 필요가 생깁니다.

===== 단일 페이지 애플리케이션 <_single_page_applications>
이 정도의 JavaScript는 매우 소박하지만, 훨씬 더 큰 개념적 접근 방식의 시작입니다. 이것은 _#indexed[단일 페이지 애플리케이션(SPA)]_입니다. 웹 애플리케이션은 더 이상 하이퍼미디어 제어(링크와 양식) 를 사용하여 페이지 간 _탐색_을 하지 않습니다.

대신, 애플리케이션은 서버와 _순수 데이터_를 교환하며, 단일 페이지 내의 콘텐츠를 업데이트합니다.

이러한 전략 또는 아키텍처가 전체 애플리케이션에 채택되면 모든 것이 "단일 페이지"에서 발생하므로 애플리케이션은 "단일 페이지 애플리케이션"이 됩니다.

단일 페이지 애플리케이션 아키텍처는 오늘날 매우 인기가 있으며, 지난 10년 동안 웹 애플리케이션 구축의 지배적인 접근 방식이었습니다. 이는 업계에서 받은 높은 수준의 관심과 논의로 확인할 수 있습니다.

오늘날 대부분의 단일 페이지 애플리케이션은 이 간단한 예제보다 훨씬 더 복잡한 프레임워크를 사용하여 사용자 인터페이스를 관리합니다. #indexed[React], #indexed[Angular], #indexed[Vue.js]와 같은 인기 라이브러리는 이제 웹 애플리케이션을 구축하는 일반적인 --- 실제로 표준 --- 방법이 되었습니다.

이보다 더 복잡한 프레임워크로 개발자는 일반적으로 클라이언트 측 모델과 함께 복잡한 작업을 수행합니다. 즉, 웹 브라우저의 메모리에 로컬로 저장된 JavaScript 객체와 "모델" 또는 애플리케이션의 "도메인"을 다루고 있습니다. 이러한 JavaScript 객체는 JavaScript 코드에 의해 업데이트되며, 프레임워크는 이러한 변경 사항에 "반응"하여 사용자 인터페이스를 업데이트합니다.

사용자 인터페이스가 사용자의 업데이트에 따라 변경될 때 이러한 변경 내용 또한 모델 객체로 흐릅니다. 이는 "양방향" 바인딩 메커니즘을 설정합니다: 모델은 UI를 업데이트할 수 있고, UI도 모델을 업데이트할 수 있습니다.

이는 하이퍼미디어보다 훨씬 더 정교한 웹 클라이언트 접근 방식이며, 일반적으로 브라우저에서 사용할 수 있는 기본 하이퍼미디어 인프라를 거의 완전히 무시합니다.

HTML은 여전히 사용자 인터페이스를 구축하는 데 사용되지만, 두 가지 주요 하이퍼미디어 제어인 앵커와 양식의 _하이퍼미디어_ 측면은 사용되지 않습니다. 이 태그들은 서버와의 상호작용에서 그들의 본래 _하이퍼미디어_ 메커니즘과 상호작용하지 않으며, 사용자 인터페이스 요소로서 존재하여 JavaScript를 통해 메모리 내의 도메인 모델과 연결되는 방식으로 작용합니다. 이후서버와는 일반 데이터 JSON API를 사용하여 동기화합니다.

따라서, 위의 간단한 버튼과 마찬가지로, 단일 페이지 애플리케이션 접근 방식은 하이퍼미디어 아키텍처를 포기합니다. 이는 웹의 기존 RESTful 아키텍처의 이점과 HTML의 기본 하이퍼미디어 제어에 내장된 기능을 무시하고 JavaScript 기반의 동작을 선호합니다.

SPAs는 _#indexed[두꺼운 클라이언트 애플리케이션]_처럼 동작합니다. 즉, 1980년대의 클라이언트-서버 애플리케이션과 비슷합니다. 이는 웹이 등장하기 전에 대중적이었던 아키텍처로, 많은 면에서 웹의 반응이기도 했습니다.

이 접근 방식이 반드시 틀렸다는 것은 아닙니다. 물론 애플리케이션에 두꺼운 클라이언트 접근 방식이 적절한 경우도 있습니다. 그러나 웹 개발자들이 이렇게 선택하는 이유와 다른 대안들을 고려하지 않는 이유에 대해 생각해 볼 필요가 있습니다.

=== 하이퍼미디어를 사용해야 하는 이유 <_why_use_hypermedia>

#blockquote(
  attribution: [Tom MacWright, https://macwright.com/2020/05/10/spa-fatigue.html],
)[
  #index[MacWright, Tom]
  웹 개발의 새로운 기준은 서버 렌더링과 함께 React 단일 페이지 애플리케이션을 구축하는 것입니다. 이 아키텍처의 두 가지 핵심 요소는 다음과 같습니다:

  1. 주요 UI는 React 또는 유사한 것을 사용하여 JavaScript로 구축하고 업데이트됩니다.

  2. 백엔드는 그 애플리케이션이 요청을 발행하는 API입니다.

  이 아이디어는 인터넷을 휩쓴 것입니다. 이는 몇 가지 주요 인기 웹사이트에서 시작되어 마케팅 사이트와 블로그와 같은 영역으로 번졌습니다.
]

JavaScript 기반의 단일 페이지 애플리케이션 접근 방식은 웹 개발 세계에 큰 반향을 일으켰고, 그 성공의 한 가지 명확한 이유는 다음과 같습니다. 단일 페이지 애플리케이션은 예전의 느리고 불안정한 웹 1.0 하이퍼미디어 기반 애플리케이션이 제공할 수 있는 것보다 훨씬 더 상호작용적이고 몰입감 있는 경험을 제공합니다. SPA는 전체 문서를 극적으로 다시 로드하지 않고도 페이지의 요소를 매끄럽게 업데이트할 수 있는 능력이 있으며, CSS 전환을 사용하여 훌륭한 비주얼 효과를 생성할 수 있고, 마우스 움직임과 같은 임의의 이벤트에 연결할 수 있는 능력을 가지고 있습니다.

이 모든 기능들은 JavaScript 기반 애플리케이션에 정교한 사용자 경험을 구축하는 데 큰 장점을 제공합니다.

이 현대 웹 애플리케이션 구축 접근 방식의 인기와 힘, 성공을 고려할 때, 하이퍼미디어와 같은 오래되고 서툰 접근 방식을 고려할 이유가 무엇일까요?

==== 자바스크립트 피로 <_javascript_fatigue>
이런 질문에 감사드립니다!

#index[hypermedia][advantages]
하이퍼미디어 아키텍처는 원래 웹 1.0 형태에서도 단일 페이지 애플리케이션 + JSON 데이터 API 접근 방식과 비교할 때 여러 가지 장점을 가지고 있습니다. 가장 큰 것 세 가지는:

- 웹 애플리케이션 구축을 위한 매우 _단순한_ 접근 방식입니다.
- 콘텐츠와 API 변경에 대해 매우 관대한 방식입니다. 사실, 그것들은 이러한 변경을 통해 더욱 발전합니다!
- 캐싱과 같은 웹 브라우저의 검증된 기능을 활용합니다.

#index[JavaScript Fatigue]
#index[JSON][API churn]
특히 첫 두 가지 장점은 현대 웹 개발의 주요 고충을 해결합니다:

- 단일 페이지 애플리케이션 인프라는 매우 복잡해져, 종종 전체 팀이 이를 관리해야 합니다.
- JSON API의 변화 --- 애플리케이션 수요를 지원하기 위한 JSON API의 지속적인 변화 ---는 많은 애플리케이션 팀에게 주요한 문제점이 되었습니다.

이 두 문제의 조합, 그리고 자바스크립트 라이브러리의 변동과 같은 다른 문제들이 결합되어 "자바스크립트 피로"라는 현상이 나타났습니다. 이는 현대 웹 애플리케이션에서 뭔가를 하는 데 필요한 많은 우여곡절로 인한 피로감을 뜻합니다.

우리는 하이퍼미디어 아키텍처가 많은 개발자와 팀에게 자바스크립트 피로를 치료하는 데 도움이 될 수 있다고 믿습니다.

그러나 하이퍼미디어가 이렇게 뛰어난데, 그것이 왜 처음부터 제쳐졌을까요? 결국 하이퍼미디어가 더 빨리 등장했으니까요. 왜 웹 개발자들은 그냥 하이퍼미디어를 고수하지 않았을까요?

하이퍼미디어가 웹 개발에서 다시 등장하지 못한 근본적인 두 가지 이유가 있습니다.

첫 번째 이유는, HTML을 _하이퍼미디어_로서의 표현력이 HTML 2.0 이후 크게 바뀌지 않았기 때문입니다. HTML 2.0은 _1990년대 중반_에 출시되었습니다. 물론 많은 새로운 _기능_이 HTML에 추가되었지만, 거의 30년 가량 하이퍼미디어로서 서버와 상호작용할 수 있는 _중요한_ 새로운 방법이 생기지 않았습니다.

HTML 개발자들은 여전히 하이퍼미디어 제어로 앵커 태그와 양식 태그만 사용할 수 있으며, 이 하이퍼미디어 제어는 여전히 `GET`과 `POST` 요청만 발행할 수 있습니다.

HTML의 이러한 놀라운 발전 부족은 두 번째 이유로 바로 이어집니다. 아마도 더 실용적인 이유로 HTML-as-hypermedia는 어려움을 겪고 있습니다: HTML의 상호작용성 및 표현력이 정체된 동안 웹 사용자들의 요구는 계속 증가하여 더욱 동적인 웹 애플리케이션을 요구하고 있습니다.

데이터 지향 JSON API에 연결된 자바스크립트 기반 애플리케이션이 이러한 더 정교한 사용자 인터페이스를 제공하는 방법이 되었습니다. 자바스크립트에서 달성할 수 있는 _사용자 경험_이 하이퍼미디어에 비해 더욱 풍부했기 때문에 웹 개발 커뮤니티는 자바스크립트 기반 단일 페이지 애플리케이션 방식으로 전환하게 되었습니다. 이러한 변화는 단일 페이지 애플리케이션이 시스템 아키텍처로서 본질적으로 우수하다는 주장에서 촉발된 것이 아닙니다.

이렇게 될 필요는 없었습니다. 하이퍼미디어의 아이디어에는 바닐라 HTML보다 더 풍부하고 표현력 있는 상호작용 모델을 가지지 못하게 하는 본질적인 제약이 없습니다. 하이퍼미디어 기반 접근 방식을 포기하기보다는, 산업에서는 HTML에서 더 많은 상호작용을 요구할 수 있었습니다.

대신에 웹 브라우저 내에서 두꺼운 클라이언트 스타일 애플리케이션 구축이 표준이 되었습니다. 이는 복잡한 애플리케이션 구축을 위한 보다 익숙한 모델로 가는 합리적인 이동이었습니다.

물론 모두가 하이퍼미디어를 제쳐두지는 않았습니다. #indexed[HyTime], #indexed[VoiceXML], #indexed[HAL]와 같은 하이퍼미디어를 발전시키려는 노력들이 있었습니다.

그러나 세계에서 가장 널리 사용되는 하이퍼미디어인 HTML은 하이퍼미디어로서의 발전을 멈췄습니다. 웹 개발 세계는 자바스크립트 기반 SPA를 수용하며 상호작용 문제를 해결했으며, 대부분은 의도하지 않게 다른 시스템 아키텍처로 완전히 전환하게 되었습니다.

=== 하이퍼미디어의 부활? <_a_hypermedia_resurgence>
HTML이 어떻게 발전할 수 있었는지 생각해 보는 것은 흥미로운 일입니다. 하이퍼미디어로서 정체되지 않고 HTML이 계속 발전할 수 있었던 방법은 무엇인가요? 새로운 하이퍼미디어 제어를 추가하고 기존 제어의 표현력을 높일 수 있었을까요? 초기 웹을 강력하고 유연하게 만든 이 원래의 하이퍼미디어 지향 RESTful 모델 내에서 현대 웹 애플리케이션을 구축할 수 있었을까요?

이것은 다소 무의미한 추측처럼 보일 수 있지만, 이와 관련해 선의의 소식이 있습니다: 지난 10년 동안 HTML이 다시 움직일 수 있도록 하려는 몇 가지 특이한 대안 프론트엔드 라이브러리가 등장했습니다. 아이러니하게도, 이러한 라이브러리는 HTML의 중심에 해당하는 기술로 자리잡았던 JavaScript로 작성되었습니다.

그러나 이러한 라이브러리는 JavaScript를 웹의 기본 하이퍼미디어 시스템에 대한 _대체재_로 사용하지 않습니다.

대신, 이들은 _하이퍼미디어_로서 HTML 자체를 보강하는 데 JavaScript를 사용합니다.

이 _하이퍼미디어 지향_ 라이브러리는 웹 애플리케이션에서 하이퍼미디어를 핵심 기술로 재조명합니다.

==== 하이퍼미디어 지향 JavaScript 라이브러리 <_hypermedia_oriented_javascript_libraries>

#index[Multi-Page Application (MPA)]
웹 개발 세계에서는 단일 페이지 애플리케이션(SPA) 접근 방식과 현재 "다중 페이지 애플리케이션"(MPA)이라고 불리는 방식 간의 ongoing debate가 있습니다. MPA는 여러 웹 페이지에 있는 링크와 양식을 사용하여 HTTP 요청을 발행하고 HTML 응답을 받는 구식 웹 1.0 애플리케이션 구축 방식의 현대적 명칭입니다.

MPA 애플리케이션은 본질적으로 하이퍼미디어 기반 애플리케이션입니다. 결국, 이 애플리케이션은 로이 필딩이 그의 논문에서 설명한 것입니다.

이러한 애플리케이션은 다소 투박하지만, 합리적으로 잘 작동합니다. 많은 웹 개발자와 팀은 단순성과 신뢰성을 위해 일반 HTML의 한계를 수용하는 것을 선택합니다.

Svelte.js의 창립자이자 SPA 측의 논쟁에서의 생각의 리더인 리치 해리스(Rich Harris)는 오래된 MPA 스타일과 새로운 SPA 스타일의 조합을 제안했습니다. 해리스는 이 웹 애플리케이션 구축 접근 방식을 "전환적"이라고 부릅니다. 이는 MPA 접근 방식과 새로운 SPA 접근 방식을 일관된 전체로 블렌딩하려고 합니다. (이는 전통과 현대 건축 스타일을 결합하는 "전환적" 건축 경향과 유사합니다.)

"전환적"은 혼합 스타일 애플리케이션에 적합한 용어이며, 두 접근 방식 간의 합리적인 타협을 제공하여 케이스별로 적절한 방식으로 사용할 수 있습니다.

하지만 이러한 타협은 여전히 불만족스럽게 느껴집니다.

우리 애플리케이션에 이러한 두 가지 매우 다른 아키텍처 모델이 있을 수밖에 없는 것인가요?

단일 페이지 애플리케이션(SPA)과 다중 페이지 애플리케이션(MPA) 간의 무역의 핵심은 _사용자 경험_ 또는 애플리케이션의 상호작용성입니다. 이는 일반적으로 애플리케이션을 위해 어떤 접근 방식을 선택해야 할지를 결정합니다. 또는 "전환적" 애플리케이션의 경우 특정 기능에 대해 그러합니다.

하이퍼미디어 지향 라이브러리를 채택함으로써 MPA와 SPA 접근 방식 간의 상호작용 격차가 극적으로 닫힙니다. 여러분은 애플리케이션의 대부분에 대해 MPA 접근 방식을 사용할 수 있으며, 사용자 인터페이스에 타협하지 않고도 그것을 가능하게 할 수 있습니다. 하이퍼미디어 접근 방식을 사용하여 _모든_ 애플리케이션 요구에 적용할 수 있을지도 모릅니다.

하이퍼미디어 주위에 약간의 SPA를 두거나 두 가지 접근 방식을 혼합하는 대신, 하이퍼미디어 기반 애플리케이션을 _주로_ 또는 _전적으로_ 생성할 수 있으며, 이 방식이 여전히 사용자에게 요구되는 상호작용을 만족시킬 수 있습니다.

이것은 웹 애플리케이션을 _엄청나게_ 단순화하고 더욱 응집력 있고 이해하기 쉬운 소프트웨어를 만들어낼 수 있습니다. 비록 우리는 나중에 더 복잡한 SPA 접근 방식에 대해 논의할 것이지만, 하이퍼미디어 우선 접근 방식과 하이퍼미디어 지향 라이브러리를 채택하여 HTML을 가능한 한 최대로 활용하면, 웹 애플리케이션은 강력하고 상호작용하며 _단순하게_ 만들 수 있습니다.

그러한 하이퍼미디어 지향 라이브러리 중 하나가 #link("https://htmx.org")[htmx]입니다. htmx는 이 책의 2부에서 초점을 맞출 것입니다. 우리는 사실상 정교한 단일 페이지 애플리케이션에서 발견되는 많은 일반 "현대" UI 기능을 하이퍼미디어 모델을 사용하여 만들 수 있음을 보여줍니다.

그리고, 그렇게 하는 것이 상쾌하게 재미있고 단순하다는 점입니다.

==== 하이퍼미디어 기반 애플리케이션 <_hypermedia_driven_applications>
htmx를 사용하여 웹 애플리케이션을 구축할 때 다중 페이지 애플리케이션이라는 용어가 _대략_ 적용되지만, 애플리케이션 아키텍처의 핵심을 완전히 설명하지는 않습니다. 여러분은 알게 되겠지만, htmx 기반의 애플리케이션은 전체 페이지를 교체할 _필요가_ 없으며, 사실상 단일 페이지 내에서 완전히 존재할 수 있습니다. 우리는 이 관행을 권장하지 않지만, 가능합니다!

따라서 htmx로 구축된 웹 애플리케이션을 "다중 페이지 애플리케이션"이라고 부르는 것은 완전히 정확하지 않습니다. 웹 1.0 MPA 접근 방식과 새로운 하이퍼미디어 지향 라이브러리 기능 기반 애플리케이션의 공통점은 _하이퍼미디어_를 그들의 핵심 기술 및 아키텍처로 사용한다는 점입니다.

따라서 우리는 이 두 가지를 모두 설명하기 위해 _하이퍼미디어 기반 애플리케이션(HDA)_이라는 용어를 사용합니다.

이는 이 두 접근 방식과 SPA 접근 방식 간의 핵심적인 차별점이 _응용 프로그램의 페이지 수_가 아니라, 기본 _시스템_ 아키텍처임을 명확히 합니다.

/ 하이퍼미디어 기반 애플리케이션 (HDA): #[
    서버와 상호작용하기 위한 주요 메커니즘으로 _하이퍼미디어_ 및 _하이퍼미디어 교환_을 사용하는 웹 애플리케이션.
  ]

그렇다면 HDA는 가까이서 어떤 모습일까요?

위의 간단한 JavaScript powered 버튼을 기반으로 한 htmx 구현을 살펴보겠습니다:

#figure(caption: [htmx 구현],
```html
<button hx-get="/contacts/1" hx-target="#contact-ui"> <1>
    연락처 가져오기
</button>
```)

1. `/contacts/1`에 `GET` 요청을 발행하여 `contact-ui`를 교체합니다.

JavaScript가 지원하는 버튼과 마찬가지로, 이 버튼은 몇 가지 속성을 주입받았습니다. 그러나 이 경우에는 (명시적인) JavaScript 스크립트가 없습니다.

대신, 앵커 태그의 `href` 속성과 양식 태그의 `action` 속성과 유사한 _선언적_ 속성들이 있습니다. `hx-get` 속성은 htmx에게 "사용자가 이 버튼을 클릭할 때, `/contacts/1`에 `GET` 요청을 발행하십시오."라고 말하고 있습니다. `hx-target` 속성은 htmx에게 "응답이 돌아오는 즉시, 결과 HTML을 `contact-ui`라는 ID를 가진 요소에 담아 주세요."라고 알려줍니다.

여기서 우리는 htmx의 핵심과 그것이 하이퍼미디어 기반 애플리케이션을 구축하는 방식을 구축하게 되는 핵심을 직면합니다:

_서버의 HTTP 응답은 JSON 형식이 아닌 HTML 형식일 것으로 기대합니다_.

htmx에 의한 요청에 대한 HTTP 응답은 다음과 같은 형태일 수 있습니다:

#figure(caption: [HTML],
```html
<details>
  <div>
    연락처: HTML 예제
  </div>
  <div>
    <a href="mailto:html-example@example.com">이메일</a>
  </div>
</details>
```)

이 작은 HTML 조각은 DOM 내의 `contact-ui`라는 ID를 가진 요소에 포함될 것입니다.

따라서 이 htmx 기반 버튼은 서버와 _하이퍼미디어_를 교환하고 있으며, 앵커 태그나 양식과 마찬가지로, 이 상호작용은 여전히 웹의 기본 하이퍼미디어 모델을 사용하고 있습니다. htmx는 이 버튼에 (JavaScript를 통해) 기능을 추가하고 있지만, 그 기능은 하이퍼미디어로서 HTML을 _보강_하는 것입니다. htmx는 웹의 하이퍼미디어 시스템을 _교체_하는 것이 아니라, 그 하이퍼미디어 시스템을 완전히 다른 아키텍처로 대체합니다.

외관상 서로 비슷해 보일 수 있지만, 이 htmx 기반 버튼과 JavaScript 기반 버튼은 매우 다른 시스템 아키텍처와 이를 기반으로 한 웹 개발 방식을 사용하고 있습니다.

이 책에서 하이퍼미디어 기반 애플리케이션을 구축하는 과정을 진행하면서 두 접근 방식 간의 차이점이 점점 더 분명해질 것입니다.

=== 하이퍼미디어를 사용해야 할 때는 언제인가요? <_when_should_you_use_hypermedia>

#index[hypermedia][when to use]
하이퍼미디어는 종종, 그러나 _항상_ 그렇지는 않지만, 웹 애플리케이션에 적합한 선택입니다.

아마도 여러분은 많은 사용자 상호작용이 _필요하지_ 않은 웹사이트나 애플리케이션을 구축하고 있을지도 모릅니다. 이러한 유용한 웹 애플리케이션은 많으며, 이로 인해 부끄러워할 필요는 없습니다! 아마존, eBay, 수많은 뉴스 사이트와 쇼핑 사이트, 포럼 등은 효과적이기 위해 많은 상호작용을 필요로 하지 않습니다. 이들은 주로 텍스트와 이미지로 구성되어 있으며, 이는 웹이 설계된 방식입니다.

어쩌면 여러분의 애플리케이션은 _서버 측_에서 대부분의 가치를 부여하며, 사용자 조정이나 정교한 데이터 분석을 수행한 후 사용자에게제시하는 방식으로 작동할 수도 있습니다. 또는 잘 설계된 데이터베이스 앞에 간단한 생성-읽기-업데이트-삭제 (CRUD) 작업을 제공함으로써 가치를 추가할 수 있습니다. 다시 말해, 이러한 부분에 부끄러워할 필요는 없습니다!

이러한 모든 경우에 하이퍼미디어 접근 방식을 사용하는 것이 훌륭한 선택이 될 것으로 보입니다. 이러한 애플리케이션의 상호작용 요구는 급격하지 않으며, 이 애플리케이션들의 많은 가치는 클라이언트 측이 아닌 서버 측에서 발생합니다.

이 모든 애플리케이션은 로이 필딩이 "큰 알갱이 하이퍼미디어 데이터 전송"이라고 부르는 것에 적합합니다: 여러분은 단순히 앵커 태그와 양식을 사용하여 요청으로부터 전체 HTML 문서를 반환하는 응답을 받을 수 있습니다. 이 과정에서 모든 것이 잘 작동합니다. 이는 웹이 설계된 목적입니다!

이러한 애플리케이션에 하이퍼미디어 접근 방식을 채택함으로써, 여러분은 단일 페이지 애플리케이션 접근 방식으로 인해 발생하는 클라이언트 측 복잡성을 상당히 줄일 수 있습니다. 클라이언트 측 라우팅, 클라이언트 측 모델 관리, JavaScript 논리의 수동 연결을 수행할 필요가 없습니다. 뒤로 가기 버튼은 "그냥 작동"할 것입니다. 딥 링크도 "그냥 작동"합니다. 여러분은 애플리케이션이 실제로 가치를 더하는 서버에 집중할 수 있게 됩니다.

또한, 이 접근 방식 위에 htmx 또는 다른 하이퍼미디어 지향 라이브러리를 쌓는다면, 바닐라 HTML과 관련하여 발생하는 많은 사용성 문제를 해결하고, 보다 세분화된 하이퍼미디어 전송을 활용할 수 있습니다. 이는 새로운 사용자 인터페이스 및 경험 가능성을 열어주어 하이퍼미디어를 사용하여 구축할 수 있는 애플리케이션의 범위를 _훨씬_ 넓힙니다.

하지만 그것은 나중에 이야기할 내용입니다.

=== 하이퍼미디어를 사용하지 말아야 할 때는 언제인가요? <_when_shouldnt_you_use_hypermedia>

#index[hypermedia][limitations]
그렇다면 _항상_ 그렇지 않은 것은 무엇인가요? 하이퍼미디어가 애플리케이션에 잘 작동하지 않을 때는 언제인가요?

즉각적으로 떠오르는 예 중 하나는 온라인 스프레드시트 애플리케이션입니다. 스프레드시트의 경우, 하나의 셀을 업데이트하면 전체 시트에서 여러 변화가 연쇄적으로 발생할 수 있습니다. 더 나쁜 것은, 이러한 변화가 _모든 키 입력_에 대해 발생해야 할 수 있습니다.

이 경우, 특정 변경 사항으로 인해 무슨 업데이트가 필요한지에 대한 명확한 경계가 없는 동적인 사용자 인터페이스를 갖게 됩니다. 각 셀 변경 사항에 대해 하이퍼미디어 스타일 서버 왕복을 도입하면 성능이 극도로 저하될 것입니다.

이는 웹의 "큰 알갱이 하이퍼미디어 데이터 전송" 접근 방식에 적합한 상황이 아닙니다. 이와 같은 애플리케이션을 위해서는 복잡한 클라이언트 측 자바스크립트 접근 방법을 사용하는 것을 권장합니다.

_그러나_ 온라인 스프레드시트의 경우에도 하이퍼미디어 접근 방식이 도움이 될 수 있는 영역이 있을 것입니다.

스프레드시트 애플리케이션은 설정 페이지를 가지고 있을 것입니다. 그리고 아마도 그 설정 페이지는 하이퍼미디어 접근 방식을 수용할 수 있습니다. 만약 그것이 서버에 유지되어야 하는 상대적으로 간단한 형태의 양식 세트라면, 하이퍼미디어는 실제로 이 애플리케이션의 일부에서도 잘 작동할 것입니다.

하이퍼미디어를 선택함으로써, 애플리케이션의 해당 부분을 상당히 간단하게 만들 수 있습니다. 그 결과 애플리케이션의 _복잡성 예산_을 심플한 것들로 유지하면서도 핵심의 복잡한 스프레드시트 로직을 수행할 수 있습니다.

설정 페이지와 같은 단순한 것에 복잡한 자바스크립트 프레임워크를 사용하는 복잡성을 낭비할 이유가 무엇인가요?

#sidebar[복잡성 예산][
  모든 소프트웨어 프로젝트에는 명시적이든 아니든 복잡성 예산이 존재합니다. 특정 개발 팀이 수용할 수 있는 복잡성의 양은 한정되어 있으며, 모든 새로운 기능과 구현 선택은 시스템의 전체적인 복잡성에 적어도 조금 더 추가하게 됩니다.

  #index[complexity budget]
  복잡성의 가장 까다로운 점은 대개 기하급수적으로 증가한다는 것입니다. 어느 날은 전체 시스템을 머리 속에 넣고 특정 변경의 결과를 이해할 수 있지만, 일주일 후에는 전체 시스템이 다루기 힘들다는 느낌이 들기도 합니다. 더 나아가, 복잡성을 관리하기 위해 도입된 추상화 또는 인프라 조치들은 종종 오히려 복잡성을 증가시키기 마련입니다. 정말로 좋은 소프트웨어 엔지니어의 일은 복잡성을 통제하는 것입니다.

  복잡성을 줄이는 확실한 방법은 가장 어렵기도 한 방법입니다: 거절하는 것입니다. 기능 요청에 대한 반발은 기술이며, 이를 잘할 수 있다면 사람들이 _그들_이 거절했다고 느끼도록 하기만 하면 됩니다.

  슬프게도, 이는 항상 가능하지는 않습니다. 어떤 기능은 반드시 구축되어야 합니다. 이 경우 질문은 "작동하는 가장 간단한 것이 무엇인가?"입니다. 하이퍼미디어 접근 방식의 가능한 옵션을 이해하는 것은 "가장 간단한 것" 툴 체스트에 또 다른 도구를 추가하는 것입니다.
]

=== 하이퍼미디어: 정교하고 현대적인 시스템 아키텍처 <_hypermedia_a_sophisticated_modern_system_architecture>
하이퍼미디어는 종종 웹 개발 분야에서 오래되고 구식의 기술로 여겨지며, 정적 웹사이트를 위한 유용한 것입니다. 그러나 현대의 정교한 웹 애플리케이션을 위한 실현 가능한 선택으로는 여겨지지 않습니다.

진심으로요? 현대 웹 애플리케이션이 그것을 사용하여 건설될 수 있다고 주장하나요?

네, 정말요.

현재의 인기 있는 의견에 반하여, 하이퍼미디어는 애플리케이션 구축을 위한 _혁신적_이고 _현대적인_ 시스템 아키텍처로, 어떤 면에서 _현재의 단일 페이지 애플리케이션 접근 방식보다 더 현대적_입니다. 이 책의 나머지 부분에서는 하이퍼미디어의 핵심 실용적 개념을 재소개하고, 이 시스템 아키텍처를 자신의 소프트웨어에서 어떻게 활용할 수 있는지 정확하게 보여줄 것입니다.

앞으로의 장에서는 이 접근 방식이 제공하는 모든 이점과 기술에 대한 확고한 이해를 발전시키게 될 것입니다. 우리는 또, 여러분이 우리만큼 열정적으로 하이퍼미디어를 바라보게 되기를 희망합니다. <_html_notes_div_soup>

#html-note[\<div\> 수프][

잘 알려진 엉망인 HTML의 종류는 `<div>` 수프입니다.

개발자들이 더 의미 있는 태그를 사용하는 대신 전반적으로 일반적인 `<div>` 및 `<span>` 요소로 돌아가면, 우리는 웹사이트의 질을 저하시키거나 우리 스스로의 작업량을 더 늘리게 됩니다 --- 아마도 두 가지 모두를 경험하게 될 것입니다.

예를 들어, 특정 버튼을 추가하는 대신 전용 `<button>` 요소를 사용하는 것이 아닌, `<div>` 요소에 `click` 이벤트 리스너를 추가할 수 있습니다.

#figure(
```html
<div class="bg-accent padding-4 rounded-2" onclick="doStuff()">
  작업 수행
</div>
```)

이 버튼에는 두 가지 주요 문제가 있습니다:

- 포커스할 수 없습니다 --- Tab 키로 이곳에 접근할 수 없습니다.

- 보조 도구가 이것이 버튼임을 알릴 방법이 없습니다.

네, 우리는 `role="button"`과 `tabindex="0"`을 추가하여 이를 수정할 수 있습니다:

#figure(
```html
<div class="bg-accent padding-4 rounded-2"
  role="button"
  tabindex="0"
  onclick="doStuff()">작업 수행</div>
```)

이들은 쉬운 수정이지만, 여러분이 _기억해야_ 하는 요소입니다. 또한 HTML 소스에서 이것이 버튼이라는 것이 명확하지 않아 소스를 읽기가 더 어렵고 이러한 속성의 부재가 발견되기 더 어렵습니다. div 수프를 가진 페이지의 소스 코드는 수정하고 디버깅하기 어렵습니다.

div 수프를 피하기 위해서는 사용 가능한 태그에 대한 HTML 사양과 친숙해지고, 각 태그를 여러분의 도구 상자의 또 다른 도구로 간주하는 것이 좋습니다. 이전에 알아보지 못한 것들이 있을 수 있습니다! (현재 사양에서 정의된 113개의 요소가 있다는 점에서, 이는 도구 _창고_에 더 가깝습니다).

물론 모든 UI 패턴은 지정된 HTML 요소를 가지지 않습니다. 종종 우리는 요소를 구성하고 속성으로 보강해야 할 필요가 있습니다. 하지만 그렇게 하기도 전에, HTML 도구 상자를 살펴보십시오. 때때로 여러분은 얼마만큼 많은 것이 제공되는지 놀라게 될 수 있습니다.
]
